<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>网络如何连接 | 标题：洛克王国</title><meta name="keywords" content="网络连接标签"><meta name="author" content="空洞骑士"><meta name="copyright" content="空洞骑士"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="网络如何连接"><meta name="application-name" content="网络如何连接"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="网络如何连接"><meta property="og:url" content="http://example.com/2025/04/29/%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5/index.html"><meta property="og:site_name" content="标题：洛克王国"><meta property="og:description" content="网络是怎样连接的[日]户根勤&amp;#x2F;著     周自恒&amp;#x2F;译（计算机网络图解趣味版） 本书的结构暂时省略，未窥得全貌 第一章 浏览器生成消息——探索浏览器内部1.1　生成HTTP请求消息1.1.1　探索之旅从输入网址开始网址，准确来说应该叫URL。 URL：uniform resourc"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="空洞骑士"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="网络是怎样连接的[日]户根勤&amp;#x2F;著     周自恒&amp;#x2F;译（计算机网络图解趣味版） 本书的结构暂时省略，未窥得全貌 第一章 浏览器生成消息——探索浏览器内部1.1　生成HTTP请求消息1.1.1　探索之旅从输入网址开始网址，准确来说应该叫URL。 URL：uniform resourc"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/04/29/%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: undefined,
  diytitle: undefined,
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 空洞骑士","link":"链接: ","source":"来源: 标题：洛克王国","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '标题：洛克王国',
  title: '网络如何连接',
  postAI: '',
  pageFillDescription: '网络是怎样连接的, 本书的结构, 第一章 浏览器生成消息, ——探索浏览器内部, 1.1　生成HTTP请求消息, 1.1.1　探索之旅从输入网址开始, 1.1.2　浏览器先要解析URL, 1.1.3　省略文件名的情况, 1.1.4　HTTP的基本思路, 1.1.5　生成HTTP请求消息, 1.1.6　发送请求后会收到响应, 1.2　向DNS服务器查询Web服务器的IP地址, 1.2.1　IP地址的基本知识, 1.2.2　域名和IP地址并用的理由, 1.2.3　Socket库提供查询IP地址的功能, 1.2.5　解析器的内部原理, , 1.3　全世界DNS服务器的大接力, 1.3.1　DNS服务器的基本工作, 1.3.2　域名的层次结构, 1.3.3　寻找相应的DNS服务器并获取IP地址, 1.3.4　通过缓存加快DNS服务器的响应, 1.4　委托协议栈发送消息, 1.4.1　数据收发操作概览, 1.4.2　创建套接字阶段, 1.4.3　连接阶段：把管道接上去, 1.4.4　通信阶段：传递消息, 1.4.5　断开阶段：收发数据结束, 第二章 用电信号传输TCPx2FIP, ——探索协议栈和网卡, 2.1　创建套接字, 2.1.1　协议栈的内部结构, 2.1.2　套接字的实体就是通信控制信息, 2.1.3　调用socket时的操作, 2.2　连接服务器, 2.2.1　连接是什么意思, 2.2.2　负责保存控制信息的头部, 2.2.3　连接操作的实际过程, 2.3　收发数据, 2.3.1　将HTTP请求消息交给协议栈, 2.3.2　对较大的数据进行拆分, , 2.3.3　使用ACK号确认网络包已收到, 2.3.4　根据网络包平均往返时间调整ACK号等待时间, 2.3.5　使用窗口有效管理ACK号, 2.3.6　ACK与窗口的合并, 2.3.7　接收HTTP响应消息, 2.4　从服务器断开并删除套接字, 2.4.1　数据发送完毕后断开连接网络是怎样连接的日户根勤著周自恒译计算机网络图解趣味版本书的结构暂时省略未窥得全貌第一章浏览器生成消息探索浏览器内部生成请求消息探索之旅从输入网址开始网址准确来说应该叫统一资源定位符网址还可以以其他一些文字开头如等浏览器是一个具备多种客户端功能的综合性客户端软件访问服务器时用而访问服务器时用根据访问目标的不同的写法也会不同表示浏览器应当使用的访问方法图的各种格式浏览器先要解析浏览器要做的第一步工作就是对进行解析从而生成发送给服务器的请求消息图浏览器解析的过程图路径名为的文件省略文件名的情况没有文件名在服务器上事先设置好文件名省略时要访问的默认文件名服务器就会访问或者这个也是以结尾的它表示访问一个根目录访问或者文件当没有路径名时就代表访问根目录下事先设置的默认文件原本叫主页也就是或者这些文件如果服务器上存在名为的文件则将作为文件名来处理如果存在名为的目录则将作为目录名来处理浏览器的第一步工作就是对进行解析的基本思路协议定义了客户端和服务器之间交互的消息内容和步骤图的基本思路请求消息中包含的内容是对什么和进行怎样的操作两个部分对什么的部分称为的内容是一个存放网页数据的文件名或者是一个程序的文件名例如等不仅限于此也可以直接使用开头的来作为节详细说明换句话说就是这里可以写各种访问目标而这些访问目标统称为进行怎样的操作的部分称为方法方法表示需要让服务器完成怎样的工作典型的例子包括读取表示的数据将客户端输入的数据发送给表示的程序等表的主要方法消息中还有一些用来表示附加信息的头字段图中的消息头头字段属于可有可无的附加信息客户端向服务器发送数据时会先发送头字段再发送数据图中的消息体收到请求消息之后将结果存放在响应消息中在响应消息的开头有一个状态码它用来表示操作的执行结果是成功还是发生了错误状态码后面就是头字段和网页数据当我们访问服务器时遇到找不到的文件就会显示出的错误信息这就是状态码补充一些关于方法的知识方法首先在请求消息中写上方法然后在中写上存放网页数据的文件名这就表示我们需要获取文件中的数据当服务器收到消息后会打开文件并读取出里面的数据然后将读出的数据存放到响应消息中并返回给客户端最后客户端浏览器会收到这些数据并显示在屏幕上方法使用方法时会指向服务器中运行的一个应用程序的文件名典型的例子包括等然后在请求消息中除了方法和之外还要加上传递给应用程序和脚本的数据这里的数据也就是用户在输入框里填写的信息表单当服务器收到消息后服务器会将请求消息中的数据发送给指定的应用程序最后服务器从应用程序接收输出的结果会将它存放到响应消息中并返回给客户端生成请求消息图消息的格式图表单中对方法的区分消息头定义了很多项目如日期客户端支持的数据类型语言压缩格式客户端和服务器的软件名称和版本数据有效期和最后更新时间等大多数情况下消息头的长度为几行到十几行不等发送请求后会收到响应关于响应消息我们将在第章详细介绍这里先粗略地了解一下第一行的内容为状态码和响应短语用来表示请求的执行结果是成功还是出错状态码是一个数字它主要用来向程序告知执行的结果响应短语是一段文字用来向人们告知执行的结果表状态码概要当网页中包含图片时会在网页中的相应位置嵌入表示图片文件的标签的控制信息就和中的插入图片一样的语言屏幕上留出用来显示图片的空间这个步骤和获取网页文件时一样由于每条请求消息中只能写个所以每次只能获取个文件条请求消息中只能写个如果需要获取多个文件必须对每个文件单独发送条请求图消息示例向服务器查询服务器的地址地址的基本知识生成消息之后接下来我们需要委托操作系统将消息发送给服务器尽管浏览器能够解析网址并生成消息但它本身并不具备将消息发送到网络中的功能因此这一功能需要委托操作系统来实现发送消息的功能对于所有应用程序来说都是通用的因此让操作系统来实现这一功能其他应用程序委托操作系统来进行操作这是一个比较合理的做法图地址的表示方法图地址的结构地址的主机号全表示整个子网全表示向子网上所有设备发送包即广播域名和地址并用的理由完全不需要库提供查询地址的功能解析器解析器客户端是一段程序它包含在操作系统的库中图现实位于应用程序之中但是无妨库是一种库其中包含的程序组件可以让其他的应用程序调用操作系统的网络功能而解析器就是这个库中的其中一种程序组件图软件采用分层结构图解析器的调用方法在应用程序中编写上图中的一行代码后就能够调用解析器完成向服务器查询地址的操作根据域名查询地址时浏览器会使用库中的解析器解析器的内部原理图调用解析器时计算机内部的工作流程上图即表明控制流程转移协议栈操作系统内部的网络控制软件也叫协议驱动驱动等全世界服务器的大接力服务器的基本工作服务器基本工作就是接收来自客户端的查询消息然后根据消息的内容返回响应客户端的查询消息包含以下种信息域名服务器邮件服务器邮件地址中后面的部分的名称的值永远是代表互联网的记录类型当类型为时表示域名对应的是地址当类型为时表示域名对应的是邮件服务器图服务器的基本工作虽然图展示的是表格形式实际上这些信息是保存在配置文件中的表格中的一行信息被称为一条资源记录服务器会从域名与地址的对照表中查找相应的记录并返回地址域名的层次结构略字面意思寻找相应的服务器并获取地址图找到目标服务器图服务器之间的查询操作通过缓存加快服务器的响应不需要从最上级的根域开始查找因为服务器有一个缓存功能可以记住之前查询过的域名当要查询的域名不存在时不存在这一响应结果也会被缓存这样当下次查询这个不存在的域名时也可以快速响应委托协议栈发送消息数据收发操作概览向操作系统内部的协议栈发出委托时需要按照指定的顺序来调用库中的程序组件使用库来收发数据的操作过程如图所示图数据通过类似管道的结构来流动收发数据的操作分为个阶段创建套接字创建套接字阶段将管道连接到服务器端的套接字上连接阶段收发数据通信阶段断开管道并删除套接字断开阶段这些委托的操作都是通过调用库中的程序组件来执行的但这些数据通信用的程序组件其实仅仅充当了一个桥梁的角色并不执行任何实质性的操作应用程序的委托内容最终会被原原本本地传递给协议栈创建套接字阶段图客户端和服务器之间收发数据操作的情形客户端创建套接字的操作非常简单只要调用库中的程序组件就可以了套接字创建完成后协议栈会返回一个描述符应用程序会将收到的描述符存放在内存中应用程序是通过描述符这一类似号码牌的东西来识别套接字的连接阶段把管道接上去应用程序通过调用库中的名为的程序组件来完成这一操作这里的要点是当调用时需要指定描述符服务器地址和端口号这个参数图描述符是用来在一台计算机内部识别套接字的机制端口号就是用来让通信的另一方能够识别出套接字的机制客户端在创建套接字时协议栈会为这个套接字随便分配一个端口号当协议栈执行连接操作时会将这个随便分配的端口号通知给服务器第二章详述当连接成功后协议栈会将对方的地址和端口号等信息保存在套接字中这样我们就可以开始收发数据了描述符应用程序用来识别套接字的机制地址和端口号客户端和服务器之间用来识别对方套接字的机制通信阶段传递消息首先应用程序需要在内存中准备好要发送的数据根据用户输入的网址生成的请求消息就是我们要发送的数据接下来当调用时需要指定描述符和发送数据图然后协议栈就会将数据发送到服务器接下来服务器执行接收操作解析收到的数据内容并执行相应的操作向客户端返回响应消息当消息返回后需要执行的是接收消息的操作接收消息的操作是通过库中的程序组件委托协议栈来完成的图调用时需要指定用于存放接收到的响应消息的内存地址这一内存地址称为接收缓冲区接收缓冲区是一块位于应用程序内部的内存空间因此当消息被存放到接收缓冲区中时就相当于已经转交给了应用程序断开阶段收发数据结束我们需要调用库的程序组件进入断开阶段图最终连接在套接字之间的管道会被断开套接字本身也会被删除使用的协议规定当服务器发送完响应消息之后应该主动执行断开操作因此服务器会首先调用来断开连接断开操作传达到客户端之后客户端的套接字也会进入断开阶段接下来当浏览器调用执行接收数据操作时会告知浏览器收发数据操作已结束连接已经断开浏览器得知后也会调用进入断开阶段版本中当所有数据都请求完成后浏览器会主动触发断开连接的操作第二章用电信号传输探索协议栈和网卡创建套接字协议栈的内部结构本章我们将探索操作系统中的网络控制软件协议栈和网络硬件网卡是如何将浏览器的消息发送给服务器的图软件采用分层结构浏览器邮件等一般应用程序收发数据时用查询等收发较短的控制数据时用套接字的实体就是通信控制信息在协议栈内部有一块用于存放控制信息的内存空间记录了用于控制通信操作的控制信息例如通信对象的地址端口号通信操作的进行状态等套接字就只是一个概念而已并不存在实体或者说存放控制信息的内存空间就是套接字的实体协议栈在执行操作时需要参阅这些控制信息例如在发送数据时需要看一看套接字中的通信对象地址和端口号以便向指定的地址和端口发送数据在发送数据之后套接字中必须要记录是否已经收到响应以及发送数据后经过了多长时间才能根据这些信息按照需要执行重发操作套接字中记录了用于控制通信操作的各种控制信息协议栈则需要根据这些信息判断下一步的行动这就是套接字的作用协议栈是根据套接字中记录的控制信息来工作的图显示套接字内容本地地址和远程地址都是这表示通信还没开始地址不确定调用时的操作图消息收发操作首先是创建套接字的阶段如图所示应用程序调用申请创建套接字协议栈根据应用程序的申请执行创建套接字的操作在这个过程中协议栈首先会分配用于存放一个套接字所需的内存空间这相当于为控制信息准备一个容器套接字刚刚创建时数据收发操作还没有开始因此需要在套接字的内存空间中写入表示这一初始状态的控制信息到这里创建套接字的操作就完成了创建套接字时首先分配一个套接字所需的内存空间然后向其中写入初始状态需要将表示这个套接字的描述符告知应用程序描述符相当于用来区分协议栈中的多个套接字的号码牌应用程序在向协议栈进行收发数据委托时就需要提供这个描述符只要通过描述符确定了相应的套接字协议栈就能够获取所有的相关信息这样一来应用程序就不需要每次都告诉协议栈应该和谁进行通信了连接服务器连接是什么意思创建套接字之后应用程序浏览器就会调用随后协议栈会将本地的套接字与服务器的套接字进行连接连接实际上是通信双方交换控制信息在套接字中记录这些必要信息并准备数据收发的一连串操作客户端套接字刚刚创建完成的时候里面并没有存放任何数据也不知道通信的对象是谁浏览器可以根据网址来查询服务器的地址而且根据规则也知道应该使用号端口但只有浏览器知道这些必要的信息是不够的因为在调用创建套接字时这些信息并没有传递给协议栈因此我们需要把服务器的地址和端口号等信息告知协议栈这是连接操作的目的之一服务器服务器上也会创建套接字插图但服务器上的协议栈和客户端一样只创建套接字是不知道应该和谁进行通信的和客户端不同的是在服务器上连应用程序也不知道通信对象是谁需要让客户端向服务器告知必要的信息比如我想和你开始通信我的地址是端口号是可见客户端向服务器传达开始通信的请求也是连接操作的目的之一连接实际上是通信双方交换控制信息在套接字中记录这些必要信息并准备数据收发的一连串操作像上面提到的客户端将地址和端口号告知服务器这样的过程就属于交换控制信息的一个具体的例子此外当执行数据收发操作时我们还需要一块用来临时存放要收发的数据的内存空间这块内存空间称为缓冲区它也是在连接操作的过程中分配的上面这些就是连接这个词代表的具体含义负责保存控制信息的头部关于控制信息这里再补充一些之前我们说的控制信息其实可以大体上分为两类表头部格式图客户端与服务器之间交换的控制信息第一类是客户端和服务器相互联络时交换的控制信息控制信息还有保存在套接字中用来控制协议栈操作的信息因此协议栈具体需要哪些信息会根据协议栈本身的实现方式不同而不同插图但这并没有什么问题因为协议栈中的控制信息通信对方是看不见的只要在通信时按照规则将必要的信息写入头部客户端和服务器之间的通信就能够得以成立例如和操作系统的内部结构不同协议栈的实现方式不同必要的控制信息也就不同但即便如此两种系统之间依然能够互相通信通信操作中使用的控制信息分为两类头部中记录的信息套接字协议栈中的内存空间中记录的信息连接操作的实际过程我们已经了解了连接操作的含义下面来看一下具体的操作过程这个过程是从应用程序调用库的开始的图描述符服务器地址和端口号上面的调用提供了服务器的地址和端口号这些信息会传递给协议栈中的模块然后模块会与该地址对应的对象也就是与服务器的模块交换控制信息这一交互过程包括下面几个步骤首先客户端先创建一个包含表示开始数据收发操作的控制信息的头部如表所示头部包含很多字段这里要关注的重点是发送方和接收方的端口号到这里客户端发送方的套接字就准确找到了服务器接收方的套接字也就是搞清楚了我应该连接哪个套接字然后我们将头部中的控制位的比特设置为大家可以认为它表示连接此外还需要设置适当的序号和窗口大小这一点我们会稍后详细讲解连接操作的第一步是在模块处创建表示连接控制信息的头部通过头部中的发送方和接收方端口号可以找到要连接的套接字当头部创建好之后接下来模块会将信息传递给模块并委托它进行发送服务器的模块根据头部中的信息找到端口号对应的套接字从处于等待连接状态的套接字中找到与头部中记录的端口号相同的套接字就可以了当找到对应的套接字之后套接字中会写入相应的信息并将状态改为正在连接上述操作完成后服务器的模块会返回响应这个过程和客户端一样需要在头部中设置发送方和接收方端口号以及比特如果由于某些原因不接受连接那么将不设置而是将比特设置为此外在返回响应时还需要将控制位设为客户端向服务器发送第一个网络包时由于服务器还没有接受过网络包所以需要将比特设为这表示已经接收到相应的网络包网络中经常会发生错误网络包也会发生丢失因此双方在通信时必须相互确认网络包是否已经送达而设置比特就是用来进行这一确认的网络包就会返回到客户端通过模块到达模块并通过头部的信息确认连接服务器的操作是否成功如果为则表示连接成功这时会向套接字中写入服务器的地址端口号等信息同时还会将状态改为连接完毕刚才服务器返回响应时将比特设置为相应地客户端也需要将比特设置为并发回服务器告诉服务器刚才的响应包已经收到当这个服务器收到这个返回包之后连接操作才算全部完成套接字就已经进入随时可以收发数据的状态了可以认为这时有一根管子把两个套接字连接了起来只要数据传输过程在持续也就是在调用断开之前连接是一直存在的建立连接之后协议栈的连接操作就结束了也就是说已经执行完毕控制流程被交回到应用程序收发数据将请求消息交给协议栈数据收发操作是从应用程序调用将要发送的数据交给协议栈开始的图协议栈并不是一收到数据就马上发送出去而是会将数据存放在内部的发送缓冲区中并等待应用程序的下一段数据一次将多少数据交给协议栈是由应用程序自行决定的协议栈并不能控制这一行为在这样的情况下如果一收到数据就马上发送出去就可能会发送大量的小包导致网络效率下降因此需要在数据积累到一定量时再发送出去至于要积累多少数据才能发送不同种类和版本的操作系统会有所不同根据下面几个要素来判断的第一个判断要素是每个网络包能容纳的数据长度最大传输单元一个网络包的最大长度以太网中一般为字节最大分段大小除去头部之后一个网络包所能容纳的数据的最大长度图与另一个判断要素是时间当应用程序发送数据的频率不高的时候可能会因为等待时间太长而造成发送延迟这种情况下即便缓冲区中的数据长度没有达到也应该果断发送出去为此协议栈的内部有一个计时器应用程序在发送数据时可以指定一些选项比如如果指定不等待填满缓冲区直接发送则协议栈就会按照要求直接发送数据像浏览器这种会话型的应用程序在向服务器发送数据时等待填满缓冲区导致延迟会产生很大影响因此一般会使用直接发送的选项对较大的数据进行拆分图应用程序数据的拆分发送使用号确认网络包已收到具备确认对方是否成功收到网络包以及当对方没收到时进行重发的功能因此在发送网络包之后接下来还需要进行确认操作原理首先模块在拆分数据时会先算好每一块数据相当于从头开始的第几个字节接下来在发送这一块数据时将算好的字节数写在头部中序号字段就是派在这个用场上的然后发送数据的长度也需要告知接收方不过这个并不是放在头部里面的因为用整个网络包的长度减去头部的长度就可以得到数据的长度有了上面两个数值我们就可以知道发送的数据是从第几个字节开始长度是多少了通过这些信息接收方还能够检查收到的网络包有没有遗漏例如假设上次接收到第字节那么接下来如果收到序号为的包说明中间没有遗漏像这样如果确认没有遗漏接收方会将到目前为止接收到的数据长度加起来计算出一共已经收到了多少个字节然后将这个数值写入头部的号中发送给发送方返回号时除了要设置号的值以外还需要控制位中的比特设为这代表号字段有效接收方也就知道这个网络包时用来改制号的图序号和号的用法图的例子和实际情况还是有些出入的在实际的通信中序号并不是从开始的而是需要用随机数计算出一个初始值这是因为如果序号都从开始通信过程就会非常容易预测有人会利用这一点来发动攻击但是如果初始值是随机的那么对方就搞不清楚序号到底是从多少开始计算的因此需要在开始收发数据之前将初始值告知通信对象大家应该还记得在我们刚才讲过的连接过程中有一个将控制位设为并发送给服务器的操作就是在这一步将序号的初始值告知对方的实际上在将设为的同时还需要同时设置序号字段的值而这里的值就代表序号的初始值前面介绍了通过序号和号来进行数据确认的思路但仅凭这些还不够因为我们刚刚只考虑了单向的数据传输但数据收发是双向的在客户端向服务器发送数据的同时服务器也会向客户端发送数据因此必须要想办法应对这样的情况图数据双向传输时的情况如图所示首先客户端先计算出一个序号然后将序号和数据一起发送给服务器服务器收到之后会计算号并返回给客户端相反地服务器也需要先计算出另一个序号然后将序号和数据一起发送给客户端客户端收到之后计算号并返回给服务器如图所示客户端和服务器双方都需要各自计算序号因此双方需要在连接过程中互相告知自己计算的序号初始值图序号和号的交互来看一下实际的工作过程图首先客户端在连接时需要计算出与从客户端到服务器方向通信相关的序号初始值并将这个值发送给服务器图接下来服务器会通过这个初始值计算出号并返回给客户端图初始值有可能在通信过程中丢失因此当服务器收到初始值后需要返回号作为确认同时服务器也需要计算出与从服务器到客户端方向通信相关的序号初始值并将这个值发送给客户端图客户端也需要根据服务器发来的初始值计算出号并返回给服务器图到这里序号和号都已经准备完成了接下来就可以进入数据收发阶段了数据收发操作本身是可以双向同时进行的但中是先由客户端向服务器发送请求序号也会跟随数据一起发送图然后服务器收到数据后再返回号图从服务器向客户端发送数据的过程则正好相反图采用这样的方式确认对方是否收到了数据在得到对方确认之前发送过的包都会保存在发送缓冲区中如果对方没有返回某些包对应的号那么就重新发送这些包一机制非常强大通过这一机制我们可以确认接收方有没有收到某个包如果没有收到则重新发送这样一来无论网络中发生任何错误我们都可以发现并采取补救措施重传网络包反过来说有了这一机制我们就不需要在其他地方对错误进行补救了采用传输即便发生一些错误对方最终也能够收到正确的数据所以应用程序只管自顾自地发送这些数据就好了如果发生网络中断服务器宕机等问题那么无论怎样重传都不管用会在尝试几次重传无效之后强制结束通信并向应用程序报错通过序号和号可以确认接收方是否收到了网络包根据网络包平均往返时间调整号等待时间实际上网络的错误检测和补偿机制非常复杂下面来说几个关键的点首先是返回号的等待时间这个等待时间叫超时时间当等待时间很短时当网络传输繁忙时就会发生拥塞号的返回会变慢这时我们就必须将等待时间设置得稍微长一点否则可能会发生已经重传了包之后前面的号才姗姗来迟的情况因为号的返回变慢大多是由于网络拥塞引起的因此如果此时再出现很多多余的重传对于本来就很拥塞的网络来说无疑是雪上加霜如果等待时间过长那么包的重传就会出现很大的延迟也会导致网络速度变慢因为波动如此之大所以将等待时间设置为一个固定值并不是一个好办法因此采用了动态调整等待时间的方法这个等待时间是根据号返回所需的时间来判断的会在发送数据的过程中持续测量号的返回时间如果号返回变慢则相应延长等待时间相对地如果号马上就能返回则相应缩短等待时间使用窗口有效管理号图一来一回方式和滑动窗口方式如图所示在等待号的这段时间中如果什么都不做那实在太浪费了采用图这样的滑动窗口方式来管理数据发送和号的操作所谓滑动窗口就是在发送一个包之后不等待号返回而是直接发送后续的一系列包这样一来等待号的这段时间就被有效利用起来了如果不等返回号就连续发送包就有可能会出现发送包的频率超过接收方处理能力的情况当接收方的收到包后会先将数据存放到接收缓冲区中然后接收方需要计算号将数据块组装起来还原成原本的数据并传递给应用程序如果这些操作还没完成下一个包就到了也不用担心因为下一个包也会被暂存在接收缓冲区中如果数据到达的速率比处理这些数据并传递给应用程序的速率还要快那么接收缓冲区中的数据就会越堆越多最后就会溢出缓冲区溢出之后后面的数据就进不来了因此接收方就收不到后面的包了这就和中途出错的结果是一样的也就意味着超出了接收方处理能力我们可以通过下面的方法来避免这种情况的发生首先接收方需要告诉发送方自己最多能接收多少数据然后发送方根据这个值对数据发送操作进行控制这就是滑动窗口方式的基本思路图滑动窗口与接收缓冲区关于滑动窗口的具体工作方式还是看图更容易理解图在这张图中接收方将数据暂存到接收缓冲区中并执行接收操作当接收操作完成后接收缓冲区中的空间会被释放出来也就可以接收更多的数据了这时接收方会通过头部中的窗口字段将自己能接收的数据量告知发送方这样一来发送方就不会发送过多的数据导致超出接收方的处理能力了实际上接收方在收到数据之后马上就会开始进行处理如果接收方的性能高处理速度比包的到达速率还快缓冲区马上就会被清空并通过窗口字段告知发送方前面提到的能够接收的最大数据量称为窗口大小它是调优参数中非常有名的一个与窗口的合并要提高收发数据的效率还需要考虑另一个问题那就是返回号和更新窗口的时机如果假定这两个参数是相互独立的分别用两个单独的包来发送结果会如何呢首先什么时候需要更新窗口大小呢当收到的数据刚刚开始填入缓冲区时其实没必要每次都向发送方更新窗口大小因为只要发送方在每次发送数据时减掉已发送的数据长度就可以自行计算出当前窗口的剩余长度因此更新窗口大小的时机应该是接收方从缓冲区中取出数据传递给应用程序的时候因此当接收方将数据传递给应用程序导致接收缓冲区剩余容量增加时就需要告知发送方这就是更新窗口大小的时机那么号又是什么情况呢当接收方收到数据时如果确认内容没有问题就应该向发送方返回号因此我们可以认为收到数据之后马上就应该进行这一操作因此接收方在发送号和窗口更新时并不会马上把包发送出去而是会等待一段时间在这个过程中很有可能会出现其他的通知操作这样就可以把两种通知合并在一个包里面发送了当需要连续发送多个号时也可以减少包的数量只要发送最后一个号就可以了中间的可以全部省略当需要连续发送多个窗口更新时也可以减少包的数量因为连续发生窗口更新说明应用程序连续请求了数据接收缓冲区的剩余空间连续增加这种情况和号一样可以省略中间过程只要发送最终的结果就可以了接收响应消息发送请求消息后接下来还需要等待服务器返回响应消息首先浏览器在委托协议栈发送请求消息之后会调用程序之前的图来获取响应消息然后控制流程会通过转移到协议栈然后协议栈会执行接下来的操作和发送数据一样接收数据也需要将数据暂存到接收缓冲区中这里的操作过程如下首先协议栈尝试从接收缓冲区中取出数据并传递给应用程序但这个时候请求消息刚刚发送出去响应消息可能还没返回响应消息的返回还需要等待一段时间因此这时接收缓冲区中并没有数据那么接收数据的操作也就无法继续这时协议栈会将应用程序的委托也就是从接收缓冲区中取出数据并传递给应用程序的工作暂时挂起等服务器返回的响应消息到达之后再继续执行接收操作议栈接收数据的具体操作过程已经在发送数据的部分讲解过了因此这里我们就简单总结一下首先协议栈会检查收到的数据块和头部的内容判断是否有数据丢失如果没有问题则返回号然后协议栈将数据块暂存到接收缓冲区中并将数据块按顺序连接起来还原出原始的数据最后将数据交给应用程序具体来说协议栈会将接收到的数据复制到应用程序指定的内存地址中然后将控制流程交回应用程序将数据交给应用程序之后协议栈还需要找到合适的时机向发送方发送窗口更新从服务器断开并删除套接字数据发送完毕后断开连接',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-04 16:23:31',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">标题：洛克王国</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><span> 我的</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/?id=9486110474&amp;server=tencent"><span> 音乐馆</span></a></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://blog.hollowknight.dpdns.org/weichat-qrcode.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://blog.hollowknight.dpdns.org/weichat-qrcode.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay-qrcode.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/img/alipay-qrcode.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%A0%87%E7%AD%BE/" style="font-size: 1.05rem;">网络连接标签<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a></div></div><h1 class="post-title" itemprop="name headline">网络如何连接</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-04-29T13:12:48.000Z" title="发表于 2025-04-29 21:12:48">2025-04-29</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-05-04T08:23:31.353Z" title="更新于 2025-05-04 16:23:31">2025-05-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为地球村"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>地球村</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/04/29/%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5/"><header><h1 id="CrawlerTitle" itemprop="name headline">网络如何连接</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">空洞骑士</span><time itemprop="dateCreated datePublished" datetime="2025-04-29T13:12:48.000Z" title="发表于 2025-04-29 21:12:48">2025-04-29</time><time itemprop="dateCreated datePublished" datetime="2025-05-04T08:23:31.353Z" title="更新于 2025-05-04 16:23:31">2025-05-04</time></header><h1 id="网络是怎样连接的"><a href="#网络是怎样连接的" class="headerlink" title="网络是怎样连接的"></a>网络是怎样连接的</h1><p>[日]户根勤&#x2F;著     周自恒&#x2F;译（计算机网络图解趣味版）</p>
<h2 id="本书的结构"><a href="#本书的结构" class="headerlink" title="本书的结构"></a>本书的结构</h2><p>暂时省略，未窥得全貌</p>
<h3 id="第一章-浏览器生成消息"><a href="#第一章-浏览器生成消息" class="headerlink" title="第一章 浏览器生成消息"></a>第一章 浏览器生成消息</h3><h3 id="——探索浏览器内部"><a href="#——探索浏览器内部" class="headerlink" title="——探索浏览器内部"></a>——探索浏览器内部</h3><h4 id="1-1-生成HTTP请求消息"><a href="#1-1-生成HTTP请求消息" class="headerlink" title="1.1　生成HTTP请求消息"></a>1.1　生成HTTP请求消息</h4><h5 id="1-1-1-探索之旅从输入网址开始"><a href="#1-1-1-探索之旅从输入网址开始" class="headerlink" title="1.1.1　探索之旅从输入网址开始"></a>1.1.1　探索之旅从输入网址开始</h5><p>网址，准确来说应该叫URL。 URL：uniform resource locator，统一资源定位符。</p>
<p>网址还可以以其他一些文字开头如“http:”，“ftp:”，“file:”，“mailto:”等。</p>
<p>浏览器是一个具备多种客户端功能的综合性客户端软件。</p>
<p>访问Web服务器时用“http:”，而访问FTP服务器时用“ftp:”。</p>
<p>根据访问目标的不同，URL的写法也会不同。</p>
<p>“http:”，“ftp:”，“file:”，“mailto:”表示浏览器应当使用的访问方法。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog.hollowknight.dpdns.org/picture/DM_20250208140344_001.jpg" alt="DM_20250208140344_001" style="zoom: 50%;" />

<p><code>图1.1　URL的各种格式</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog.hollowknight.dpdns.org/picture/DM_20250208141426_001.jpg"></p>
<h5 id="1-1-2-浏览器先要解析URL"><a href="#1-1-2-浏览器先要解析URL" class="headerlink" title="1.1.2　浏览器先要解析URL"></a>1.1.2　浏览器先要解析URL</h5><p>浏览器要做的第一步工作就是对URL进行解析，从而生成发送给Web服务器的请求消息。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208141400_001.jpg" alt="DM_20250208141400_001" style="zoom:50%;" />

<p><code>图1.2　Web浏览器解析URL的过程</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208141426_001.jpg" alt="DM_20250208141426_001" style="zoom:50%;" />

<p><code>图1.3　路径名为/dir/file1.html的文件</code></p>
<h5 id="1-1-3-省略文件名的情况"><a href="#1-1-3-省略文件名的情况" class="headerlink" title="1.1.3　省略文件名的情况"></a>1.1.3　省略文件名的情况</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a)http://www.lab.glasscom.com/dir/</span><br></pre></td></tr></table></figure>

<p>没有文件名，在服务器上事先设置好文件名省略时要访问的默认文件名。</p>
<p>服务器就会访问&#x2F;dir&#x2F;index.html或者&#x2F;dir&#x2F;default.htm。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(b)http://www.lab.glasscom.com/</span><br></pre></td></tr></table></figure>

<p>这个URL也是以“&#x2F;”结尾的，它表示访问一个根目录。</p>
<p>访问&#x2F;index.html或者&#x2F;default.htm文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(c)http://www.lab.glasscom.com</span><br></pre></td></tr></table></figure>

<p>当没有路径名时，就代表访问根目录下事先设置的默认文件（原本叫主页）</p>
<p>也就是&#x2F;index.html或者&#x2F;default.htm这些文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(d)http://www.lab.glasscom.com/whatisthis</span><br></pre></td></tr></table></figure>

<p>如果Web服务器上存在名为whatisthis的文件，则将whatisthis作为文件名来处理；</p>
<p>如果存在名为whatisthis的目录，则将whatisthis作为目录名来处理。</p>
<table>
<thead>
<tr>
<th>浏览器的第一步工作就是对URL进行解析。</th>
</tr>
</thead>
</table>
<h5 id="1-1-4-HTTP的基本思路"><a href="#1-1-4-HTTP的基本思路" class="headerlink" title="1.1.4　HTTP的基本思路"></a>1.1.4　HTTP的基本思路</h5><p><strong>HTTP协议</strong>：定义了客户端和服务器之间交互的消息内容和步骤<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208143003_001.jpg" alt="DM_20250208143003_001" style="zoom:50%;" /></p>
<p><code>图1.4　HTTP的基本思路</code></p>
<p><strong>请求消息</strong>中包含的内容是“对什么”和“进行怎样的操作”两个部分。</p>
<p>“对什么”的部分称为URI。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URI的内容是一个存放网页数据的文件名或者是一个CGI程序的文件名，</span><br><span class="line">例如“/dir1/file1.html” “/dir1/program1.cgi”等。</span><br><span class="line">URI不仅限于此，也可以直接使用“http:”开头的URL来作为URI。（5.43节详细说明）</span><br><span class="line">换句话说就是，这里可以写各种访问目标，而这些访问目标统称为URI。</span><br></pre></td></tr></table></figure>

<p>“进行怎样的操作”的部分称为方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法表示需要让Web服务器完成怎样的工作，</span><br><span class="line">典型的例子包括读取URI表示的数据、将客户端输入的数据发送给URI表示的程序等。</span><br></pre></td></tr></table></figure>



<p>表1.1　HTTP的主要方法</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208143709_001.jpg" alt="DM_20250208143709_001" style="zoom: 50%;" />

<p>HTTP消息中还有一些用来表示附加信息的头字段。（图1.5中的消息头）头字段属于可有可无的附加信息。</p>
<p>客户端向Web服务器发送数据时，会先发送头字段，再发送数据（图1.5中的消息体）。</p>
<p>收到请求消息之后，将结果存放在<strong>响应消息</strong>中。</p>
<p>在响应消息的开头有一个状态码，它用来表示操作的执行结果是成功还是发生了错误。</p>
<p>状态码后面就是头字段和网页数据。</p>
<p>当我们访问Web服务器时，遇到找不到的文件就会显示出404 Not Found的错误信息，</p>
<p>这就是状态码。</p>
<p><strong>补充一些关于HTTP方法的知识</strong></p>
<p>GET方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先，在请求消息中写上GET方法，然后在URI中写上存放网页数据的文件名“/dir1/file1.html”，这就表示我们需要获取/dir1/file1.html文件中的数据。</span><br><span class="line">当Web服务器收到消息后，会打开/dir1/file1.html文件并读取出里面的数据，</span><br><span class="line">然后将读出的数据存放到响应消息中，并返回给客户端。</span><br><span class="line">最后，客户端浏览器会收到这些数据并显示在屏幕上。</span><br></pre></td></tr></table></figure>

<p>POST方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用POST方法时，URI会指向Web服务器中运行的一个应用程序的文件名，典型的例子包括“index.cgi” “index.php”等。</span><br><span class="line">然后，在请求消息中，除了方法和URI之外，还要加上传递给应用程序和脚本的数据。这里的数据也就是用户在输入框里填写的信息。（表单）</span><br><span class="line">当服务器收到消息后，Web服务器会将请求消息中的数据发送给URI指定的应用程序。</span><br><span class="line">最后，Web服务器从应用程序接收输出的结果，会将它存放到响应消息中并返回给客户端。</span><br></pre></td></tr></table></figure>



<h5 id="1-1-5-生成HTTP请求消息"><a href="#1-1-5-生成HTTP请求消息" class="headerlink" title="1.1.5　生成HTTP请求消息"></a>1.1.5　生成HTTP请求消息</h5><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208150407_001.jpg" alt="DM_20250208150407_001" style="zoom:50%;" />

<p><code>图1.5　HTTP消息的格式</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208150635_001.jpg" alt="DM_20250208150635_001" style="zoom:50%;" />

<p><code>图1.6　表单中对方法的区分</code></p>
<p><strong>消息头</strong>：定义了很多项目，如日期、客户端支持的数据类型、语言、压缩格式、客户端和服务器的软件名称和版本、数据有效期和最后更新时间等。</p>
<p>大多数情况下消息头的长度为几行到十几行不等。</p>
<h5 id="1-1-6-发送请求后会收到响应"><a href="#1-1-6-发送请求后会收到响应" class="headerlink" title="1.1.6　发送请求后会收到响应"></a>1.1.6　发送请求后会收到响应</h5><p>关于<strong>响应消息</strong>我们将在第6章详细介绍，这里先粗略地了解一下。</p>
<p>第一行的内容为状态码和响应短语，用来表示请求的执行结果是成功还是出错。</p>
<p>状态码是一个数字，它主要用来向程序告知执行的结果；</p>
<p>响应短语是一段文字，用来向人们告知执行的结果。</p>
<p>表1.3　HTTP状态码概要</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208151218_001.jpg" alt="DM_20250208151218_001" style="zoom:50%;" />





<p>当网页中包含图片时，会在网页中的相应位置嵌入表示图片文件的标签的控制信息。</p>
<p>(就和typora中的插入图片一样的<code>&lt;img src=&quot;image1.jpg&quot;&gt;</code> HTML语言)</p>
<p>屏幕上留出用来显示图片的空间，这个步骤和获取网页文件时一样。</p>
<p>由于每条请求消息中只能写1个URI，所以每次只能获取1个文件。</p>
<table>
<thead>
<tr>
<th>1条请求消息中只能写1个URI。如果需要获取多个文件，必须对每个文件单独发送1条请求。</th>
</tr>
</thead>
</table>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208152130_001.jpg" alt="DM_20250208152130_001" style="zoom:50%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208152159_001.jpg" alt="DM_20250208152159_001" style="zoom:50%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208152200_001.jpg" alt="DM_20250208152200_001" style="zoom:50%;" />

<p><code>图1.7　HTTP消息示例</code></p>
<h4 id="1-2-向DNS服务器查询Web服务器的IP地址"><a href="#1-2-向DNS服务器查询Web服务器的IP地址" class="headerlink" title="1.2　向DNS服务器查询Web服务器的IP地址"></a>1.2　向DNS服务器查询Web服务器的IP地址</h4><h5 id="1-2-1-IP地址的基本知识"><a href="#1-2-1-IP地址的基本知识" class="headerlink" title="1.2.1　IP地址的基本知识"></a>1.2.1　IP地址的基本知识</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">生成HTTP消息之后，接下来我们需要委托操作系统将消息发送给Web服务器。</span><br><span class="line">尽管浏览器能够解析网址并生成HTTP消息，但它本身并不具备将消息发送到网络中的功能，</span><br><span class="line">因此这一功能需要委托操作系统来实现。</span><br><span class="line"></span><br><span class="line">发送消息的功能对于所有应用程序来说都是通用的，因此让操作系统来实现这一功能，其他应用程序委托操作系统来进行操作，这是一个比较合理的做法。</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208162156_001.jpg" alt="DM_20250208162156_001" style="zoom:50%;" />

<p><code>图1.9　IP地址的表示方法</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208162300_001.jpg" alt="DM_20250208162300_001" style="zoom:50%;" />

<p><code>图1.10　IP地址的结构</code></p>
<table>
<thead>
<tr>
<th><strong>IP地址的主机号</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>全0：表示整个子网</strong></td>
</tr>
<tr>
<td><strong>全1：表示向子网上所有设备发送包，即“广播”</strong></td>
</tr>
</tbody></table>
<h5 id="1-2-2-域名和IP地址并用的理由"><a href="#1-2-2-域名和IP地址并用的理由" class="headerlink" title="1.2.2　域名和IP地址并用的理由"></a>1.2.2　域名和IP地址并用的理由</h5><p>完全不需要</p>
<h5 id="1-2-3-Socket库提供查询IP地址的功能"><a href="#1-2-3-Socket库提供查询IP地址的功能" class="headerlink" title="1.2.3　Socket库提供查询IP地址的功能"></a>1.2.3　Socket库提供查询IP地址的功能</h5><p><strong>解析器</strong>（DNS解析器&#x2F;DNS客户端）是一段程序，它包含在操作系统的Socket库中。</p>
<p>（图2.1现实位于应用程序之中，但是无妨）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Socket库是一种库，其中包含的程序组件可以让其他的应用程序调用操作系统的网络功能，</span><br><span class="line">而解析器就是这个库中的其中一种程序组件。</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208162835_001.jpg" alt="DM_20250208162835_001" style="zoom:50%;" />

<p><code>图2.1　TCP/IP软件采用分层结构</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208163129_001 (1).jpg" alt="DM_20250208163129_001 (1)" style="zoom:50%;" />

<p><code>图1.11　解析器的调用方法</code>     </p>
<p><code>在应用程序中编写上图中的一行代码后就能够调用解析器完成向DNS服务器查询IP地址的操作。</code></p>
<table>
<thead>
<tr>
<th>根据域名查询IP地址时，浏览器会使用Socket库中的解析器。</th>
</tr>
</thead>
</table>
<h5 id="1-2-5-解析器的内部原理"><a href="#1-2-5-解析器的内部原理" class="headerlink" title="1.2.5　解析器的内部原理"></a>1.2.5　解析器的内部原理</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208163408_001.jpg" alt="DM_20250208163408_001" style="zoom:50%;" /></h5><p><code>图1.12　调用解析器时计算机内部的工作流程</code></p>
<p>上图即表明控制流程转移</p>
<p><strong>协议栈</strong>：操作系统内部的网络控制软件，也叫”协议驱动“，”TCP&#x2F;IP驱动“等</p>
<h4 id="1-3-全世界DNS服务器的大接力"><a href="#1-3-全世界DNS服务器的大接力" class="headerlink" title="1.3　全世界DNS服务器的大接力"></a>1.3　全世界DNS服务器的大接力</h4><h5 id="1-3-1-DNS服务器的基本工作"><a href="#1-3-1-DNS服务器的基本工作" class="headerlink" title="1.3.1　DNS服务器的基本工作"></a>1.3.1　DNS服务器的基本工作</h5><p><strong>DNS服务器</strong>：基本工作就是接收来自客户端的查询消息，然后根据消息的内容返回响应。</p>
<p>客户端的查询消息包含以下3种信息：</p>
<p>(a)域名 ：服务器、邮件服务器（邮件地址中@后面的部分）的名称</p>
<p>(b)Class ：Class的值永远是代表互联网的IN</p>
<p>(c)记录类型 ：当类型为A时，表示域名对应的是IP地址；</p>
<p>​						当类型为MX时，表示域名对应的是邮件服务器。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208164458_001-1739004309279-18.jpg" alt="DM_20250208164458_001" style="zoom:50%;" />

<p><code>图1.14　DNS服务器的基本工作</code></p>
<p>虽然图1.14展示的是表格形式，实际上这些信息是保存在配置文件中的，</p>
<p>表格中的一行信息被称为一条资源记录。</p>
<table>
<thead>
<tr>
<th>DNS服务器会从域名与IP地址的对照表中查找相应的记录，并返回IP地址。</th>
</tr>
</thead>
</table>
<h5 id="1-3-2-域名的层次结构"><a href="#1-3-2-域名的层次结构" class="headerlink" title="1.3.2　域名的层次结构"></a>1.3.2　域名的层次结构</h5><p>略，字面意思</p>
<h5 id="1-3-3-寻找相应的DNS服务器并获取IP地址"><a href="#1-3-3-寻找相应的DNS服务器并获取IP地址" class="headerlink" title="1.3.3　寻找相应的DNS服务器并获取IP地址"></a>1.3.3　寻找相应的DNS服务器并获取IP地址</h5><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208165040_001.jpg" alt="DM_20250208165040_001" style="zoom:50%;" />

<p><code>图1.15　找到目标DNS服务器</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208165112_001.jpg" alt="DM_20250208165112_001" style="zoom:50%;" />

<p><code>图1.16　DNS服务器之间的查询操作</code></p>
<h5 id="1-3-4-通过缓存加快DNS服务器的响应"><a href="#1-3-4-通过缓存加快DNS服务器的响应" class="headerlink" title="1.3.4　通过缓存加快DNS服务器的响应"></a>1.3.4　通过缓存加快DNS服务器的响应</h5><p>不需要从最上级的根域开始查找，因为DNS服务器有一个<strong>缓存</strong>功能，可以记住之前查询过的域名。</p>
<p>当要查询的域名不存在时，“不存在”这一响应结果也会被缓存。这样，当下次查询这个不存在的域名时，也可以快速响应。</p>
<h4 id="1-4-委托协议栈发送消息"><a href="#1-4-委托协议栈发送消息" class="headerlink" title="1.4　委托协议栈发送消息"></a>1.4　委托协议栈发送消息</h4><h5 id="1-4-1-数据收发操作概览"><a href="#1-4-1-数据收发操作概览" class="headerlink" title="1.4.1　数据收发操作概览"></a>1.4.1　数据收发操作概览</h5><table>
<thead>
<tr>
<th>向操作系统内部的协议栈发出委托时，需要按照指定的顺序来调用Socket库中的程序组件。</th>
</tr>
</thead>
</table>
<p>使用Socket库来收发数据的操作过程如图1.17所示</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208191014_001.jpg" alt="DM_20250208191014_001" style="zoom:50%;" />

<p><code>图1.17　数据通过类似管道的结构来流动</code></p>
<p>收发数据的操作分为4个阶段。</p>
<p>(1)创建套接字（创建套接字阶段）</p>
<p>(2)将管道连接到服务器端的套接字上（连接阶段）</p>
<p>(3)收发数据（通信阶段）</p>
<p>(4)断开管道并删除套接字（断开阶段）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这些委托的操作都是通过调用Socket库中的程序组件来执行的，</span><br><span class="line">但这些数据通信用的程序组件其实仅仅充当了一个桥梁的角色，并不执行任何实质性的操作，</span><br><span class="line">应用程序的委托内容最终会被原原本本地传递给协议栈。</span><br></pre></td></tr></table></figure>



<h5 id="1-4-2-创建套接字阶段"><a href="#1-4-2-创建套接字阶段" class="headerlink" title="1.4.2　创建套接字阶段"></a>1.4.2　创建套接字阶段</h5><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250208192127_001.jpg" alt="DM_20250208192127_001" style="zoom:50%;" />

<p><code>图1.18　客户端和服务器之间收发数据操作的情形</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端创建套接字的操作非常简单，</span><br><span class="line">只要调用Socket库中的socket程序组件就可以了</span><br><span class="line">套接字创建完成后，协议栈会返回一个描述符，</span><br><span class="line">应用程序会将收到的描述符存放在内存中。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>应用程序是通过“描述符”这一类似号码牌的东西来识别套接字的。</th>
</tr>
</thead>
</table>
<h5 id="1-4-3-连接阶段：把管道接上去"><a href="#1-4-3-连接阶段：把管道接上去" class="headerlink" title="1.4.3　连接阶段：把管道接上去"></a>1.4.3　连接阶段：把管道接上去</h5><p>应用程序通过调用Socket库中的名为connect的程序组件来完成这一操作。</p>
<p>这里的要点是当调用connect时，需要指定<strong>描述符</strong>、<strong>服务器IP地址</strong>和<strong>端口号</strong>这3个参数（图1.18②）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">描述符是用来在一台计算机内部识别套接字的机制，</span><br><span class="line">端口号就是用来让通信的另一方能够识别出套接字的机制。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端在创建套接字时，协议栈会为这个套接字随便分配一个端口号。</span><br><span class="line">当协议栈执行连接操作时，会将这个随便分配的端口号通知给服务器。（第二章详述）</span><br><span class="line">当连接成功后，协议栈会将对方的IP地址和端口号等信息保存在套接字中，</span><br><span class="line">这样我们就可以开始收发数据了。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left"><strong>描述符：应用程序用来识别套接字的机制</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>IP地址和端口号：客户端和服务器之间用来识别对方套接字的机制</strong></td>
</tr>
</tbody></table>
<h5 id="1-4-4-通信阶段：传递消息"><a href="#1-4-4-通信阶段：传递消息" class="headerlink" title="1.4.4　通信阶段：传递消息"></a>1.4.4　通信阶段：传递消息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">首先，应用程序需要在内存中准备好要发送的数据。</span><br><span class="line">根据用户输入的网址生成的HTTP请求消息就是我们要发送的数据。</span><br><span class="line">接下来，当调用write时，需要指定描述符和发送数据（图1.18③），</span><br><span class="line">然后协议栈就会将数据发送到服务器。</span><br><span class="line"></span><br><span class="line">接下来，服务器执行接收操作，解析收到的数据内容并执行相应的操作，</span><br><span class="line">向客户端返回响应消息。</span><br><span class="line">当消息返回后，需要执行的是接收消息的操作。</span><br><span class="line">接收消息的操作是通过Socket库中的read程序组件委托协议栈来完成的（图1.18③&#x27;）。</span><br></pre></td></tr></table></figure>

<p>调用read时需要指定用于存放接收到的响应消息的内存地址，这一内存地址称为<strong>接收缓冲区</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接收缓冲区是一块位于应用程序内部的内存空间，</span><br><span class="line">因此当消息被存放到接收缓冲区中时，就相当于已经转交给了应用程序。</span><br></pre></td></tr></table></figure>

<h5 id="1-4-5-断开阶段：收发数据结束"><a href="#1-4-5-断开阶段：收发数据结束" class="headerlink" title="1.4.5　断开阶段：收发数据结束"></a>1.4.5　断开阶段：收发数据结束</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">我们需要调用Socket库的close程序组件进入断开阶段（图1.18④）。</span><br><span class="line">最终，连接在套接字之间的管道会被断开，套接字本身也会被删除。</span><br><span class="line"></span><br><span class="line">Web使用的HTTP协议规定，当Web服务器发送完响应消息之后，应该主动执行断开操作，</span><br><span class="line">因此Web服务器会首先调用close来断开连接。</span><br><span class="line">断开操作传达到客户端之后，客户端的套接字也会进入断开阶段。</span><br><span class="line">接下来，当浏览器调用read执行接收数据操作时，</span><br><span class="line">read会告知浏览器收发数据操作已结束，连接已经断开。</span><br><span class="line">浏览器得知后，也会调用close进入断开阶段。</span><br></pre></td></tr></table></figure>

<p>HTTP版本1.1中，当所有数据都请求完成后，浏览器会主动触发断开连接的操作。</p>
<h3 id="第二章-用电信号传输TCP-IP"><a href="#第二章-用电信号传输TCP-IP" class="headerlink" title="第二章 用电信号传输TCP&#x2F;IP"></a>第二章 用电信号传输TCP&#x2F;IP</h3><h3 id="——探索协议栈和网卡"><a href="#——探索协议栈和网卡" class="headerlink" title="——探索协议栈和网卡"></a>——探索协议栈和网卡</h3><h4 id="2-1-创建套接字"><a href="#2-1-创建套接字" class="headerlink" title="2.1　创建套接字"></a>2.1　创建套接字</h4><h5 id="2-1-1-协议栈的内部结构"><a href="#2-1-1-协议栈的内部结构" class="headerlink" title="2.1.1　协议栈的内部结构"></a>2.1.1　协议栈的内部结构</h5><p>本章我们将探索操作系统中的网络控制软件（<strong>协议栈</strong>）和网络硬件（<strong>网卡</strong>）</p>
<p>是如何将浏览器的消息发送给服务器的。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250210153230_001.jpg" alt="DM_20250210153230_001" style="zoom:50%;" />

<p><code>图2.1　TCP/IP软件采用分层结构</code></p>
<table>
<thead>
<tr>
<th><strong>浏览器、邮件等一般应用程序收发数据时用TCP;</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>DNS查询等收发较短的控制数据时用UDP。</strong></td>
</tr>
</tbody></table>
<h5 id="2-1-2-套接字的实体就是通信控制信息"><a href="#2-1-2-套接字的实体就是通信控制信息" class="headerlink" title="2.1.2　套接字的实体就是通信控制信息"></a>2.1.2　套接字的实体就是通信控制信息</h5><p>在协议栈内部有一块用于存放控制信息的内存空间，记录了用于控制通信操作的<strong>控制信息</strong>，例如通信对象的IP地址、端口号、通信操作的进行状态等。</p>
<p><strong>套接字</strong>就只是一个概念而已，并不存在实体，或者说存放控制信息的内存空间就是套接字的实体。</p>
<p>协议栈在执行操作时需要参阅这些控制信息。</p>
<p>例如，在发送数据时，需要看一看套接字中的通信对象IP地址和端口号，以便向指定的IP地址和端口发送数据。</p>
<p>在发送数据之后，套接字中必须要记录是否已经收到响应，以及发送数据后经过了多长时间，才能根据这些信息按照需要执行重发操作。</p>
<p>套接字中记录了用于控制通信操作的各种控制信息，协议栈则需要根据这些信息判断下一步的行动，这就是套接字的作用。</p>
<table>
<thead>
<tr>
<th>协议栈是根据套接字中记录的控制信息来工作的。</th>
</tr>
</thead>
</table>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250210154356_001.jpg" alt="DM_20250210154356_001" style="zoom:50%;" />

<p><code>图2.2　显示套接字内容</code></p>
<p>本地IP地址和远程IP地址都是0.0.0.0，这表示通信还没开始，IP地址不确定。</p>
<h5 id="2-1-3-调用socket时的操作"><a href="#2-1-3-调用socket时的操作" class="headerlink" title="2.1.3　调用socket时的操作"></a>2.1.3　调用socket时的操作</h5><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250210154611_001.jpg" alt="DM_20250210154611_001" style="zoom:50%;" />

<p><code>图2.3　消息收发操作</code></p>
<p>首先是创建套接字的阶段。如图2.3①所示，应用程序调用socket申请创建套接字，协议栈根据应用程序的申请执行创建套接字的操作。</p>
<p>在这个过程中，协议栈首先会分配用于存放一个套接字所需的内存空间。这相当于为控制信息准备一个容器。套接字刚刚创建时，数据收发操作还没有开始，因此需要在套接字的内存空间中写入表示这一初始状态的控制信息。到这里，创建套接字的操作就完成了。</p>
<table>
<thead>
<tr>
<th>创建套接字时，首先分配一个套接字所需的内存空间，然后向其中写入初始状态。</th>
</tr>
</thead>
</table>
<p>需要将表示这个套接字的描述符告知应用程序。描述符相当于用来区分协议栈中的多个套接字的号码牌。应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。</p>
<p>只要通过描述符确定了相应的套接字，协议栈就能够获取所有的相关信息，这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信了。</p>
<h4 id="2-2-连接服务器"><a href="#2-2-连接服务器" class="headerlink" title="2.2　连接服务器"></a>2.2　连接服务器</h4><h5 id="2-2-1-连接是什么意思"><a href="#2-2-1-连接是什么意思" class="headerlink" title="2.2.1　连接是什么意思"></a>2.2.1　连接是什么意思</h5><p>创建套接字之后，应用程序（浏览器）就会调用connect，随后协议栈会将本地的套接字与服务器的套接字进行连接。</p>
<p><strong>连接</strong>实际上是<strong>通信双方交换控制信息</strong>，在套接字中记录这些必要信息并准备数据收发的一连串操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端：</span><br><span class="line">套接字刚刚创建完成的时候，里面并没有存放任何数据，也不知道通信的对象是谁。浏览器可以根据网址来查询服务器的IP地址，而且根据规则也知道应该使用80号端口，但只有浏览器知道这些必要的信息是不够的，因为在调用socket创建套接字时，这些信息并没有传递给协议栈。因此，我们需要把服务器的IP地址和端口号等信息告知协议栈，这是连接操作的目的之一。</span><br><span class="line"></span><br><span class="line">服务器：</span><br><span class="line">服务器上也会创建套接字[插图]，但服务器上的协议栈和客户端一样，只创建套接字是不知道应该和谁进行通信的。和客户端不同的是，在服务器上，连应用程序也不知道通信对象是谁。</span><br></pre></td></tr></table></figure>



<p>需要让客户端向服务器告知必要的信息，比如“我想和你开始通信，我的IP地址是xxx.xxx.xxx.xxx，端口号是yyyy。”可见，客户端向服务器传达开始通信的请求，也是连接操作的目的之一。</p>
<p><strong>连接</strong>实际上是<strong>通信双方交换控制信息</strong>，在套接字中记录这些必要信息并准备数据收发的一连串操作，像上面提到的客户端将IP地址和端口号告知服务器这样的过程就属于交换控制信息的一个具体的例子。</p>
<p>此外，当执行数据收发操作时，我们还需要一块用来临时存放要收发的数据的内存空间，这块内存空间称为<strong>缓冲区</strong>，它也是在连接操作的过程中分配的。上面这些就是“连接”这个词代表的具体含义。</p>
<h5 id="2-2-2-负责保存控制信息的头部"><a href="#2-2-2-负责保存控制信息的头部" class="headerlink" title="2.2.2　负责保存控制信息的头部"></a>2.2.2　负责保存控制信息的头部</h5><p>关于<strong>控制信息</strong>，这里再<strong>补充</strong>一些。之前我们说的控制信息其实可以大体上分为两类。</p>
<p>表2.1　TCP头部格式</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250210164120_001.jpg" alt="DM_20250210164120_001" style="zoom:50%;" />



<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250210164431_001.jpg" alt="DM_20250210164431_001" style="zoom:50%;" />

<p><code>图2.4　客户端与服务器之间交换的控制信息</code></p>
<p>第一类是客户端和服务器相互联络时交换的控制信息。</p>
<p>控制信息还有保存在套接字中，用来控制协议栈操作的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">因此，“协议栈具体需要哪些信息”会根据协议栈本身的实现方式不同而不同[插图]，但这并没有什么问题。因为协议栈中的控制信息通信对方是看不见的，只要在通信时按照规则将必要的信息写入头部，客户端和服务器之间的通信就能够得以成立。</span><br><span class="line"></span><br><span class="line">例如，Windows和Linux操作系统的内部结构不同，协议栈的实现方式不同，必要的控制信息也就不同。但即便如此，两种系统之间依然能够互相通信，</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>通信操作中使用的控制信息分为两类。</th>
</tr>
</thead>
<tbody><tr>
<td>(1)头部中记录的信息</td>
</tr>
<tr>
<td>(2)套接字（协议栈中的内存空间）中记录的信息</td>
</tr>
</tbody></table>
<h5 id="2-2-3-连接操作的实际过程"><a href="#2-2-3-连接操作的实际过程" class="headerlink" title="2.2.3　连接操作的实际过程"></a>2.2.3　连接操作的实际过程</h5><p>我们已经了解了连接操作的含义，下面来看一下具体的操作过程。这个过程是从应用程序调用Socket库的connect开始的（图2.3②）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect（&lt;描述符&gt;,&lt;服务器IP地址和端口号&gt;,…）</span><br></pre></td></tr></table></figure>

<p>上面的调用提供了服务器的IP地址和端口号，这些信息会传递给协议栈中的TCP模块。然后，TCP模块会与该IP地址对应的对象，也就是与服务器的TCP模块交换控制信息，这一交互过程包括下面几个步骤。</p>
<p>首先，客户端先创建一个包含表示开始数据收发操作的控制信息的<strong>头部</strong>。如表2.1所示，头部包含很多字段，这里要关注的重点是发送方和接收方的端口号。到这里，客户端（发送方）的套接字就准确找到了服务器（接收方）的套接字，也就是搞清楚了我应该连接哪个套接字。</p>
<p>然后，我们将头部中的控制位的<strong>SYN比特设置为1</strong>，大家可以认为它表示连接。此外还需要设置适当的<strong>序号</strong>和<strong>窗口大小</strong>，这一点我们会稍后详细讲解。</p>
<table>
<thead>
<tr>
<th>连接操作的第一步是在TCP模块处创建表示连接控制信息的头部。</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>通过TCP头部中的发送方和接收方端口号可以找到要连接的套接字。</th>
</tr>
</thead>
</table>
<p>当TCP头部创建好之后，接下来TCP模块会将信息传递给IP模块并委托它进行发送。</p>
<p>服务器的<strong>TCP模块</strong>根据TCP<strong>头部</strong>中的信息找到端口号对应的套接字。从处于等待连接状态的套接字中找到与TCP头部中记录的端口号相同的套接字就可以了。</p>
<p>当找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为<strong>正在连接</strong>。</p>
<p>上述操作完成后，服务器的TCP模块会返回响应，这个过程和客户端一样，需要在TCP头部中设置发送方和接收方端口号以及SYN比特。（<strong>如果由于某些原因不接受连接，那么将不设置SYN，而是将RST比特设置为1</strong>）此外，在返回响应时还需要将ACK控制位设为1,(<strong>客户端向服务器发送第一个网络包时，由于服务器还没有接受过网络包，所以需要将ACK比特设为0</strong>)</p>
<p>这表示已经接收到相应的网络包。</p>
<p>网络中经常会发生错误，网络包也会发生丢失，因此双方在通信时必须相互确认网络包是否已经送达，而设置ACK比特就是用来进行这一确认的。</p>
<p>网络包就会返回到客户端，通过IP模块到达TCP模块，并通过TCP头部的信息确认连接服务器的操作是否成功。如果<strong>SYN为1</strong>则表示连接成功，这时会向套接字中写入服务器的<strong>IP地址</strong>、<strong>端口号</strong>等信息，同时还会将状态改为<strong>连接完毕</strong>。</p>
<p>刚才服务器返回响应时将ACK比特设置为1，相应地，客户端也需要将ACK比特设置为1并发回服务器，告诉服务器刚才的响应包已经收到。</p>
<p>当这个服务器收到这个返回包之后，连接操作才算全部完成。</p>
<p>套接字就已经进入随时可以收发数据的状态了，可以认为这时有一根管子把两个套接字连接了起来。只要数据传输过程在持续，也就是在调用close断开之前，连接是一直存在的。</p>
<p>建立连接之后，协议栈的连接操作就结束了，也就是说connect已经执行完毕，控制流程被交回到应用程序。</p>
<h4 id="2-3-收发数据"><a href="#2-3-收发数据" class="headerlink" title="2.3　收发数据"></a>2.3　收发数据</h4><h5 id="2-3-1-将HTTP请求消息交给协议栈"><a href="#2-3-1-将HTTP请求消息交给协议栈" class="headerlink" title="2.3.1　将HTTP请求消息交给协议栈"></a>2.3.1　将HTTP请求消息交给协议栈</h5><p>数据收发操作是从应用程序调用write将要发送的数据交给协议栈开始的（图2.3③）。</p>
<p>协议栈并不是一收到数据就马上发送出去，而是会将数据存放在内部的<strong>发送缓冲区</strong>中，并等待应用程序的下一段数据。</p>
<p>一次将多少数据交给协议栈是由应用程序自行决定的，协议栈并不能控制这一行为。在这样的情况下，如果一收到数据就马上发送出去，就可能会发送大量的小包，导致网络效率下降，因此需要在数据积累到一定量时再发送出去。</p>
<p>至于要积累多少数据才能发送，不同种类和版本的操作系统会有所不同。</p>
<p>根据下面<strong>几个要素</strong>来判断的</p>
<p>第<strong>一个</strong>判断要素是每个网络包能容纳的数据长度</p>
<table>
<thead>
<tr>
<th><strong>MTU（最大传输单元）：一个网络包的最大长度，以太网中一般为1500字节。</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>MSS（最大分段大小）：除去头部之后，一个网络包所能容纳的TCP数据的最大长度。</strong></td>
</tr>
</tbody></table>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250210173217_001.jpg" alt="DM_20250210173217_001" style="zoom:50%;" />

<p><code>图2.5　MTU与MSS</code></p>
<p><strong>另一个</strong>判断要素是时间</p>
<p>当应用程序发送数据的频率不高的时候，可能会因为等待时间太长而造成发送延迟，</p>
<p>这种情况下，即便缓冲区中的数据长度没有达到MSS，也应该果断发送出去。</p>
<p>为此，协议栈的内部有一个计时器.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">应用程序在发送数据时可以指定一些选项，比如如果指定“不等待填满缓冲区直接发送”，则协议栈就会按照要求直接发送数据。像浏览器这种会话型的应用程序在向服务器发送数据时，等待填满缓冲区导致延迟会产生很大影响，因此一般会使用直接发送的选项。</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2-对较大的数据进行拆分"><a href="#2-3-2-对较大的数据进行拆分" class="headerlink" title="2.3.2　对较大的数据进行拆分"></a>2.3.2　对较大的数据进行拆分</h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250210174125_001.jpg" alt="DM_20250210174125_001" style="zoom:50%;" /></h5><p><code>图2.6　应用程序数据的拆分发送</code></p>
<h5 id="2-3-3-使用ACK号确认网络包已收到"><a href="#2-3-3-使用ACK号确认网络包已收到" class="headerlink" title="2.3.3　使用ACK号确认网络包已收到"></a>2.3.3　使用ACK号确认网络包已收到</h5><p>TCP具备确认对方是否成功收到网络包，以及当对方没收到时进行重发的功能，因此在发送网络包之后，接下来还需要进行确认操作。</p>
<p>原理：</p>
<p>首先，TCP模块在拆分数据时，会先算好每一块数据相当于从头开始的第几个字节，接下来在发送这一块数据时，将算好的字节数写在TCP头部中，“序号”字段就是派在这个用场上的。</p>
<p>然后，发送数据的长度也需要告知接收方，不过这个并不是放在TCP头部里面的，因为用整个网络包的长度减去头部的长度就可以得到数据的长度。</p>
<p>有了上面两个数值，我们就可以知道发送的数据是从第几个字节开始，长度是多少了。通过这些信息，接收方还能够检查收到的网络包有没有遗漏。</p>
<p>例如，假设上次接收到第1460字节，那么接下来如果收到序号为1461的包，说明中间没有遗漏；像这样，如果确认没有遗漏，接收方会将到目前为止接收到的数据长度加起来，计算出一共已经收到了多少个字节，然后将这个数值写入TCP头部的ACK号中发送给发送方。</p>
<p>（返回ACK号时，除了要设置ACK号的值以外，还需要控制位中的ACK比特设为1，这代表ACK号字段有效，接收方也就知道这个网络包时用来改制ACK号的）</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250215143200_001.jpg" alt="DM_20250215143200_001" style="zoom:50%;" />

<p><code>图2.7　序号和ACK号的用法</code></p>
<p>图2.7的例子和实际情况还是有些出入的。在实际的通信中，序号并不是从1开始的，而是需要用随机数计算出一个初始值，这是因为如果序号都从1开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。</p>
<p>但是如果初始值是随机的，那么对方就搞不清楚序号到底是从多少开始计算的，因此需要在开始收发数据之前将<strong>初始值</strong>告知通信对象。</p>
<p>大家应该还记得在我们刚才讲过的连接过程中，有一个将<strong>SYN控制位设为1</strong>并发送给服务器的操作，就是在这一步将序号的<strong>初始值告知对方</strong>的。实际上，在将SYN设为1的同时，还需要同时设置序号字段的值，而这里的值就代表序号的初始值。</p>
<p>前面介绍了通过序号和ACK号来进行数据确认的思路，但仅凭这些还不够，因为我们刚刚只考虑了单向的数据传输，但TCP数据收发是双向的，在客户端向服务器发送数据的同时，服务器也会向客户端发送数据，因此必须要想办法应对这样的情况。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250215143733_001.jpg" alt="DM_20250215143733_001" style="zoom:50%;" />

<p><code>图2.8　数据双向传输时的情况</code></p>
<p>如图2.8所示。首先客户端先计算出一个序号，然后将序号和数据一起发送给服务器，服务器收到之后会计算ACK号并返回给客户端；相反地，服务器也需要先计算出另一个序号，然后将序号和数据一起发送给客户端，客户端收到之后计算ACK号并返回给服务器。</p>
<p>如图所示，客户端和服务器双方都需要各自计算序号，因此双方需要在连接过程中互相告知自己计算的序号初始值。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250215144048_001.jpg" alt="DM_20250215144048_001" style="zoom:50%;" />

<p><code>图2.9　序号和ACK号的交互</code></p>
<p>来看一下实际的工作过程（图2.9）。首先，客户端在连接时需要计算出与从客户端到服务器方向通信相关的序号初始值，并将这个值发送给服务器（图2.9①）。</p>
<p>接下来，服务器会通过这个初始值计算出ACK号并返回给客户端（图2.9②）。初始值有可能在通信过程中丢失，因此当服务器收到初始值后需要返回ACK号作为确认。同时，服务器也需要计算出与从服务器到客户端方向通信相关的序号初始值，并将这个值发送给客户端（图2.9②）。</p>
<p>客户端也需要根据服务器发来的初始值计算出ACK号并返回给服务器（图2.9③）。</p>
<p>到这里，序号和ACK号都已经准备完成了，接下来就可以进入数据收发阶段了。数据收发操作本身是可以双向同时进行的，但Web中是先由客户端向服务器发送请求，序号也会跟随数据一起发送（图2.9④）。</p>
<p>然后，服务器收到数据后再返回ACK号（图2.9⑤）。</p>
<p>从服务器向客户端发送数据的过程则正好相反（图2.9⑥⑦）。</p>
<p>TCP采用这样的方式确认对方是否收到了数据，在得到对方确认之前，发送过的包都会保存在发送缓冲区中。如果对方没有返回某些包对应的ACK号，那么就重新发送这些包。</p>
<p>一机制非常强大。通过这一机制，我们可以确认接收方有没有收到某个包，如果没有收到则重新发送，这样一来，无论网络中发生任何错误，我们都可以发现并采取补救措施（重传网络包）。反过来说，有了这一机制，我们就不需要在其他地方对错误进行补救了。</p>
<p>采用TCP传输，即便发生一些错误对方最终也能够收到正确的数据，所以应用程序只管自顾自地发送这些数据就好了。如果发生网络中断、服务器宕机等问题，那么无论TCP怎样重传都不管用。TCP会在尝试几次重传无效之后强制结束通信，并向应用程序报错。</p>
<table>
<thead>
<tr>
<th>通过“序号”和“ACK号”可以确认接收方是否收到了网络包。</th>
</tr>
</thead>
</table>
<h5 id="2-3-4-根据网络包平均往返时间调整ACK号等待时间"><a href="#2-3-4-根据网络包平均往返时间调整ACK号等待时间" class="headerlink" title="2.3.4　根据网络包平均往返时间调整ACK号等待时间"></a>2.3.4　根据网络包平均往返时间调整ACK号等待时间</h5><p>实际上网络的错误检测和补偿机制非常复杂。下面来说几个关键的点，首先是返回ACK号的等待时间（这个等待时间叫超时时间）。</p>
<p>当等待时间很短时，当网络传输繁忙时就会发生拥塞，ACK号的返回会变慢，这时我们就必须将等待时间设置得稍微长一点，否则可能会发生已经重传了包之后，前面的ACK号才姗姗来迟的情况。因为ACK号的返回变慢大多是由于网络拥塞引起的，因此如果此时再出现很多多余的重传，对于本来就很拥塞的网络来说无疑是雪上加霜。</p>
<p>如果等待时间过长，那么包的重传就会出现很大的延迟，也会导致网络速度变慢。</p>
<p>因为波动如此之大，所以将等待时间设置为一个固定值并不是一个好办法。因此，TCP采用了动态调整等待时间的方法，这个等待时间是根据ACK号返回所需的时间来判断的。TCP会在发送数据的过程中持续测量ACK号的返回时间，如果ACK号返回变慢，则相应延长等待时间；相对地，如果ACK号马上就能返回，则相应缩短等待时间。</p>
<h5 id="2-3-5-使用窗口有效管理ACK号"><a href="#2-3-5-使用窗口有效管理ACK号" class="headerlink" title="2.3.5　使用窗口有效管理ACK号"></a>2.3.5　使用窗口有效管理ACK号</h5><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250215145222_001.jpg" alt="DM_20250215145222_001" style="zoom:50%;" />

<p><code>图2.10　一来一回方式和滑动窗口方式</code></p>
<p>如图2.10(a)所示，在等待ACK号的这段时间中，如果什么都不做那实在太浪费了。</p>
<p>采用图2.10(b)这样的滑动窗口方式来管理数据发送和ACK号的操作。</p>
<p>所谓滑动窗口，就是在发送一个包之后，不等待ACK号返回，而是直接发送后续的一系列包。这样一来，等待ACK号的这段时间就被有效利用起来了。</p>
<p>如果不等返回ACK号就连续发送包，就有可能会出现发送包的频率超过接收方处理能力的情况。</p>
<p>当接收方的TCP收到包后，会先将数据存放到接收缓冲区中。然后，接收方需要计算ACK号，将数据块组装起来还原成原本的数据并传递给应用程序，如果这些操作还没完成下一个包就到了也不用担心，因为下一个包也会被暂存在接收缓冲区中。</p>
<p>如果数据到达的速率比处理这些数据并传递给应用程序的速率还要快，那么接收缓冲区中的数据就会越堆越多，最后就会溢出。缓冲区溢出之后，后面的数据就进不来了，因此接收方就收不到后面的包了，这就和中途出错的结果是一样的，也就意味着超出了接收方处理能力。</p>
<p>我们可以通过下面的方法来避免这种情况的发生。首先，接收方需要告诉发送方自己最多能接收多少数据，然后发送方根据这个值对数据发送操作进行控制，这就是滑动窗口方式的基本思路。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Typora\Typora picture\DM_20250215145701_001.jpg" alt="DM_20250215145701_001" style="zoom:50%;" />

<p><code>图2.11　滑动窗口与接收缓冲区</code></p>
<p>关于滑动窗口的具体工作方式，还是看图更容易理解（图2.11）。在这张图中，接收方将数据暂存到接收缓冲区中并执行接收操作。当接收操作完成后，接收缓冲区中的空间会被释放出来，也就可以接收更多的数据了。</p>
<p>这时接收方会通过TCP头部中的窗口字段将自己能接收的数据量告知发送方。这样一来，发送方就不会发送过多的数据，导致超出接收方的处理能力了。</p>
<p>实际上，接收方在收到数据之后马上就会开始进行处理，如果接收方的性能高，处理速度比包的到达速率还快，缓冲区马上就会被清空，并通过窗口字段告知发送方。</p>
<p>前面提到的能够接收的最大数据量称为<strong>窗口大小</strong>，它是TCP调优参数中非常有名的一个。</p>
<h5 id="2-3-6-ACK与窗口的合并"><a href="#2-3-6-ACK与窗口的合并" class="headerlink" title="2.3.6　ACK与窗口的合并"></a>2.3.6　ACK与窗口的合并</h5><p>要提高收发数据的效率，还需要考虑另一个问题，那就是返回ACK号和更新窗口的时机。如果假定这两个参数是相互独立的，分别用两个单独的包来发送，结果会如何呢？</p>
<p>首先，什么时候需要更新窗口大小呢？当收到的数据刚刚开始填入缓冲区时，其实没必要每次都向发送方更新窗口大小，因为只要发送方在每次发送数据时减掉已发送的数据长度就可以自行计算出当前窗口的剩余长度。</p>
<p>因此，更新窗口大小的时机应该是接收方从缓冲区中取出数据传递给应用程序的时候。</p>
<p>因此当接收方将数据传递给应用程序，导致接收缓冲区剩余容量增加时，就需要告知发送方，这就是更新窗口大小的时机。</p>
<p>那么ACK号又是什么情况呢？当接收方收到数据时，如果确认内容没有问题，就应该向发送方返回ACK号，因此我们可以认为收到数据之后马上就应该进行这一操作。</p>
<p>因此，接收方在发送ACK号和窗口更新时，并不会马上把包发送出去，而是会等待一段时间，在这个过程中很有可能会出现其他的通知操作，这样就可以把两种通知合并在一个包里面发送了。</p>
<p>当需要连续发送多个ACK号时，也可以减少包的数量。只要发送最后一个ACK号就可以了，中间的可以全部省略。当需要连续发送多个窗口更新时也可以减少包的数量，因为连续发生窗口更新说明应用程序连续请求了数据，接收缓冲区的剩余空间连续增加。这种情况和ACK号一样，可以省略中间过程，只要发送最终的结果就可以了。</p>
<h5 id="2-3-7-接收HTTP响应消息"><a href="#2-3-7-接收HTTP响应消息" class="headerlink" title="2.3.7　接收HTTP响应消息"></a>2.3.7　接收HTTP响应消息</h5><p>发送HTTP请求消息后，接下来还需要等待Web服务器返回响应消息。</p>
<p>首先，浏览器在委托协议栈发送请求消息之后，会调用read程序（之前的图2.3④）来获取响应消息。</p>
<p>然后，控制流程会通过read转移到协议栈，然后协议栈会执行接下来的操作。</p>
<p>和发送数据一样，接收数据也需要将数据暂存到接收缓冲区中，这里的操作过程如下。首先，协议栈尝试从接收缓冲区中取出数据并传递给应用程序，但这个时候请求消息刚刚发送出去，响应消息可能还没返回。响应消息的返回还需要等待一段时间，因此这时接收缓冲区中并没有数据，那么接收数据的操作也就无法继续。</p>
<p>这时，协议栈会将应用程序的委托，也就是从接收缓冲区中取出数据并传递给应用程序的工作暂时挂起，等服务器返回的响应消息到达之后再继续执行接收操作。</p>
<p>议栈接收数据的具体操作过程已经在发送数据的部分讲解过了，因此这里我们就简单总结一下。首先，协议栈会检查收到的数据块和TCP头部的内容，判断是否有数据丢失，如果没有问题则返回ACK号。然后，协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，最后将数据交给应用程序。具体来说，协议栈会将接收到的数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序。将数据交给应用程序之后，协议栈还需要找到合适的时机向发送方发送窗口更新。</p>
<h4 id="2-4-从服务器断开并删除套接字"><a href="#2-4-从服务器断开并删除套接字" class="headerlink" title="2.4　从服务器断开并删除套接字"></a>2.4　从服务器断开并删除套接字</h4><h5 id="2-4-1-数据发送完毕后断开连接"><a href="#2-4-1-数据发送完毕后断开连接" class="headerlink" title="2.4.1　数据发送完毕后断开连接"></a>2.4.1　数据发送完毕后断开连接</h5></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">空洞骑士</div><div class="post-copyright__author_desc">副标题在这</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/04/29/%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/04/29/%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5/')">网络如何连接</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://blog.hollowknight.dpdns.org/weichat-qrcode.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog.hollowknight.dpdns.org/weichat-qrcode.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay-qrcode.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/alipay-qrcode.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/04/29/%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">标题：洛克王国</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2025/04/29/hello-world/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">描述在这</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">空洞骑士</h1><div class="author-info__desc">副标题在这</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://v.douyin.com/xKMiLFrgq9I" target="_blank" title="tiktok"><i class="anzhiyufont anzhiyu-icon-tiktok"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/404074687" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84"><span class="toc-number">1.</span> <span class="toc-text">网络是怎样连接的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E4%B9%A6%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">本书的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%94%9F%E6%88%90%E6%B6%88%E6%81%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">第一章 浏览器生成消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%94%E2%80%94%E6%8E%A2%E7%B4%A2%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">——探索浏览器内部</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%94%9F%E6%88%90HTTP%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.1　生成HTTP请求消息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1-%E6%8E%A2%E7%B4%A2%E4%B9%8B%E6%97%85%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%BC%80%E5%A7%8B"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">1.1.1　探索之旅从输入网址开始</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%88%E8%A6%81%E8%A7%A3%E6%9E%90URL"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">1.1.2　浏览器先要解析URL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-3-%E7%9C%81%E7%95%A5%E6%96%87%E4%BB%B6%E5%90%8D%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.1.2.1.3.</span> <span class="toc-text">1.1.3　省略文件名的情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-4-HTTP%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">1.1.2.1.4.</span> <span class="toc-text">1.1.4　HTTP的基本思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-5-%E7%94%9F%E6%88%90HTTP%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF"><span class="toc-number">1.1.2.1.5.</span> <span class="toc-text">1.1.5　生成HTTP请求消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-6-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E5%90%8E%E4%BC%9A%E6%94%B6%E5%88%B0%E5%93%8D%E5%BA%94"><span class="toc-number">1.1.2.1.6.</span> <span class="toc-text">1.1.6　发送请求后会收到响应</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%90%91DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9F%A5%E8%AF%A2Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84IP%E5%9C%B0%E5%9D%80"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2　向DNS服务器查询Web服务器的IP地址</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">1.2.1　IP地址的基本知识</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-%E5%9F%9F%E5%90%8D%E5%92%8CIP%E5%9C%B0%E5%9D%80%E5%B9%B6%E7%94%A8%E7%9A%84%E7%90%86%E7%94%B1"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">1.2.2　域名和IP地址并用的理由</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-Socket%E5%BA%93%E6%8F%90%E4%BE%9B%E6%9F%A5%E8%AF%A2IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.2.2.3.</span> <span class="toc-text">1.2.3　Socket库提供查询IP地址的功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-5-%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.2.4.</span> <span class="toc-text">1.2.5　解析器的内部原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.1.2.2.5.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%85%A8%E4%B8%96%E7%95%8CDNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%A4%A7%E6%8E%A5%E5%8A%9B"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">1.3　全世界DNS服务器的大接力</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-1-DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">1.3.1　DNS服务器的基本工作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-%E5%9F%9F%E5%90%8D%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.3.2.</span> <span class="toc-text">1.3.2　域名的层次结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-3-%E5%AF%BB%E6%89%BE%E7%9B%B8%E5%BA%94%E7%9A%84DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E8%8E%B7%E5%8F%96IP%E5%9C%B0%E5%9D%80"><span class="toc-number">1.1.2.3.3.</span> <span class="toc-text">1.3.3　寻找相应的DNS服务器并获取IP地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-4-%E9%80%9A%E8%BF%87%E7%BC%93%E5%AD%98%E5%8A%A0%E5%BF%ABDNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%93%8D%E5%BA%94"><span class="toc-number">1.1.2.3.4.</span> <span class="toc-text">1.3.4　通过缓存加快DNS服务器的响应</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%A7%94%E6%89%98%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">1.4　委托协议栈发送消息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-1-%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E6%A6%82%E8%A7%88"><span class="toc-number">1.1.2.4.1.</span> <span class="toc-text">1.4.1　数据收发操作概览</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-2-%E5%88%9B%E5%BB%BA%E5%A5%97%E6%8E%A5%E5%AD%97%E9%98%B6%E6%AE%B5"><span class="toc-number">1.1.2.4.2.</span> <span class="toc-text">1.4.2　创建套接字阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-3-%E8%BF%9E%E6%8E%A5%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%8A%8A%E7%AE%A1%E9%81%93%E6%8E%A5%E4%B8%8A%E5%8E%BB"><span class="toc-number">1.1.2.4.3.</span> <span class="toc-text">1.4.3　连接阶段：把管道接上去</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-4-%E9%80%9A%E4%BF%A1%E9%98%B6%E6%AE%B5%EF%BC%9A%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF"><span class="toc-number">1.1.2.4.4.</span> <span class="toc-text">1.4.4　通信阶段：传递消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-5-%E6%96%AD%E5%BC%80%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9D%9F"><span class="toc-number">1.1.2.4.5.</span> <span class="toc-text">1.4.5　断开阶段：收发数据结束</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%94%A8%E7%94%B5%E4%BF%A1%E5%8F%B7%E4%BC%A0%E8%BE%93TCP-IP"><span class="toc-number">1.1.3.</span> <span class="toc-text">第二章 用电信号传输TCP&#x2F;IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%94%E2%80%94%E6%8E%A2%E7%B4%A2%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%92%8C%E7%BD%91%E5%8D%A1"><span class="toc-number">1.1.4.</span> <span class="toc-text">——探索协议栈和网卡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%88%9B%E5%BB%BA%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">2.1　创建套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.4.1.1.</span> <span class="toc-text">2.1.1　协议栈的内部结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-2-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%AE%9E%E4%BD%93%E5%B0%B1%E6%98%AF%E9%80%9A%E4%BF%A1%E6%8E%A7%E5%88%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.4.1.2.</span> <span class="toc-text">2.1.2　套接字的实体就是通信控制信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-3-%E8%B0%83%E7%94%A8socket%E6%97%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.4.1.3.</span> <span class="toc-text">2.1.3　调用socket时的操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">2.2　连接服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-%E8%BF%9E%E6%8E%A5%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-number">1.1.4.2.1.</span> <span class="toc-text">2.2.1　连接是什么意思</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-2-%E8%B4%9F%E8%B4%A3%E4%BF%9D%E5%AD%98%E6%8E%A7%E5%88%B6%E4%BF%A1%E6%81%AF%E7%9A%84%E5%A4%B4%E9%83%A8"><span class="toc-number">1.1.4.2.2.</span> <span class="toc-text">2.2.2　负责保存控制信息的头部</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3-%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E9%99%85%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.4.2.3.</span> <span class="toc-text">2.2.3　连接操作的实际过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">2.3　收发数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-%E5%B0%86HTTP%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF%E4%BA%A4%E7%BB%99%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="toc-number">1.1.4.3.1.</span> <span class="toc-text">2.3.1　将HTTP请求消息交给协议栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-%E5%AF%B9%E8%BE%83%E5%A4%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%8B%86%E5%88%86"><span class="toc-number">1.1.4.3.2.</span> <span class="toc-text">2.3.2　对较大的数据进行拆分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-1"><span class="toc-number">1.1.4.3.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3-%E4%BD%BF%E7%94%A8ACK%E5%8F%B7%E7%A1%AE%E8%AE%A4%E7%BD%91%E7%BB%9C%E5%8C%85%E5%B7%B2%E6%94%B6%E5%88%B0"><span class="toc-number">1.1.4.3.4.</span> <span class="toc-text">2.3.3　使用ACK号确认网络包已收到</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4-%E6%A0%B9%E6%8D%AE%E7%BD%91%E7%BB%9C%E5%8C%85%E5%B9%B3%E5%9D%87%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4%E8%B0%83%E6%95%B4ACK%E5%8F%B7%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4"><span class="toc-number">1.1.4.3.5.</span> <span class="toc-text">2.3.4　根据网络包平均往返时间调整ACK号等待时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-5-%E4%BD%BF%E7%94%A8%E7%AA%97%E5%8F%A3%E6%9C%89%E6%95%88%E7%AE%A1%E7%90%86ACK%E5%8F%B7"><span class="toc-number">1.1.4.3.6.</span> <span class="toc-text">2.3.5　使用窗口有效管理ACK号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-6-ACK%E4%B8%8E%E7%AA%97%E5%8F%A3%E7%9A%84%E5%90%88%E5%B9%B6"><span class="toc-number">1.1.4.3.7.</span> <span class="toc-text">2.3.6　ACK与窗口的合并</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-7-%E6%8E%A5%E6%94%B6HTTP%E5%93%8D%E5%BA%94%E6%B6%88%E6%81%AF"><span class="toc-number">1.1.4.3.8.</span> <span class="toc-text">2.3.7　接收HTTP响应消息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%AD%E5%BC%80%E5%B9%B6%E5%88%A0%E9%99%A4%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">2.4　从服务器断开并删除套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-1-%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E5%AE%8C%E6%AF%95%E5%90%8E%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.1.4.4.1.</span> <span class="toc-text">2.4.1　数据发送完毕后断开连接</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/29/%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5/" title="网络如何连接">网络如何连接</a><time datetime="2025-04-29T13:12:48.000Z" title="发表于 2025-04-29 21:12:48">2025-04-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/29/hello-world/" title="Hello World">Hello World</a><time datetime="2025-04-29T12:25:10.170Z" title="发表于 2025-04-29 20:25:10">2025-04-29</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text">nihao! 我是小骑士</div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2025 By <a class="footer-bar-link" href="/" title="空洞骑士" target="_blank">空洞骑士</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><span> 我的</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/?id=9486110474&amp;server=tencent"><span> 音乐馆</span></a></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("05/01/2025 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2025 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 空洞骑士 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>